{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Chapter5_Feb_13\"\noutput: \n  html_document: \n    keep_md: yes\n---\npage 201\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n#5.3.4 The Bootstrap\n\n```{r}\nlibrary (ISLR)\nalpha.fn=function (data ,index){\nX=data$X [index]\nY=data$Y [index]\nreturn ((var(Y)-cov (X,Y))/(var(X)+var(Y) -2* cov(X,Y)))\n}\n```\n\n```{r}\nalpha.fn(Portfolio ,1:100)\n# 0.576\nset.seed (1)\nalpha.fn(Portfolio ,sample (100 ,100 , replace =T)) #The command uses the sample() function to randomly select 100 observations from the range 1 to 100, with replacement\n# 0.596\n```\n\n```{r}\nlibrary (boot)\nboot(data = Portfolio , statistic = alpha.fn, R = 1000)\n```\n\n```{r}\nboot.fn=function (data ,index ) # to see the intercept and slope\n+ return (coef(lm(mpg~horsepower ,data=data ,subset =index)))\nboot.fn(Auto ,1:392)\n```\n\n```{r}\nset.seed (1)\nboot.fn(Auto ,sample (392 ,392 , replace =T))\nboot.fn(Auto ,sample (392 ,392 , replace =T))\n```\n\n```{r}\nboot(Auto ,boot.fn ,1000)\nsummary (lm(mpg~horsepower ,data=Auto))$coef\n```\n\n```{r}\nboot.fn=function (data ,index)\n+ coefficients(lm(mpg~horsepower +I(horsepower ^2) ,data=data ,\nsubset =index))\nset.seed (1)\nboot(Auto ,boot.fn ,1000)\nboot(data = Auto , statistic = boot.fn, R = 1000)\nsummary (lm(mpg~horsepower +I(horsepower ^2) ,data=Auto))$coef\n\n```\n\n#Probs\n\n2. We will now derive the probability that a given observation is part\nof a bootstrap sample. Suppose that we obtain a bootstrap sample\nfrom a set of n observations.\n\n(a) What is the probability that the first bootstrap observation is\nnot the jth observation from the original sample? Justify your\nanswer.\n1 - 1/n\n(b) What is the probability that the second bootstrap observation\nis not the jth observation from the original sample?\n1 - 1/n\n\n(c) Argue that the probability that the jth observation is not in the\nbootstrap sample is (1 − 1/n)n.\nwe sample with replacement so each observation in the bootstrap sample has the same 1/n (independent) chance ofthe jth observation. So for a total of n observations gives us \n(1 - 1/n)^n\n\n(d) When n = 5, what is the probability that the jth observation is\nin the bootstrap sample?\n1 - (1 - 1/5)^5 = 1 - (4/5)^5 = 67.2%\n\n(e) When n = 100, what is the probability that the jth observation\nis in the bootstrap sample?\n1 - (1 - 1/100)^{10} = 1 - (99/100)^{100} = 63.4%\n\n(f) When n = 10, 000, what is the probability that the jth observation\nis in the bootstrap sample?\n1 - (1 - 1/10000)^{10000} = 63.2%\n\n(g) Create a plot that displays, for each integer value of n from 1\nto 100, 000, the probability that the jth observation is in the\nbootstrap sample. Comment on what you observe.\n\n```{r}\npr = function(n) return(1 - (1 - 1/n)^n)\nx = 1:100000\nplot(x, pr(x))\n#The plot in about 63.2%.\n```\n\n(h) We will now investigate numerically the probability that a bootstrap\nsample of size n = 100 contains the jth observation. Here\nj = 4. We repeatedly create bootstrap samples, and each time\nwe record whether or not the fourth observation is contained in\nthe bootstrap sample.\n```{r}\nstore=rep (NA , 10000)\nfor (i in 1:10000) {\nstore[i]=sum(sample (1:100 , rep =TRUE)==4) >0\n}\nmean(store)\n```\n\n```{r}\nset.seed(1)\nstore = rep(NA, 10000)\nfor (i in 1:10000) {\n  store[i] = sum(sample(1:100, rep=T) == 4) > 0\n}\nmean(store)\n#The numerical results show an  mean probability of 64.1%, close to our theoretically result\n```\n\n4. Suppose that we use some statistical learning method to make a prediction\nfor the response Y for a particular value of the predictor X.\nCarefully describe how we might estimate the standard deviation of\nour prediction.\n\nFor making the method to predict the response Y for a particular value of the predictor X we could estimate the standard deviation of our prediction by using the bootstrap approach. The bootstrap method acts by repeatedly sampling observations (with replacement) from the original data set n times, for some large value of n, each time fitting a new model and subsequently obtaining the RMSE of the estimates for all n models.\n\n6. We continue to consider the use of a logistic regression model to\npredict the probability of default using income and balance on the\nDefault data set. In particular, we will now compute estimates for\nthe standard errors of the income and balance logistic regression coefficients\nin two different ways: (1) using the bootstrap, and (2) using\nthe standard formula for computing the standard errors in the glm()\nfunction. Do not forget to set a random seed before beginning your\nanalysis.\n\n(a) Using the summary() and glm() functions, determine the estimated\nstandard errors for the coefficients associated with income\nand balance in a multiple logistic regression model that uses\nboth predictors.\n\n```{r}\nlibrary(ISLR)\nsummary(Default)\nattach(Default)\nset.seed(1)\nglm.fit = glm(default~income+balance, data=Default, family=binomial)\nsummary(glm.fit)\n```\n\n(b) Write a function, boot.fn(), that takes as input the Default data\nset as well as an index of the observations, and that outputs\nthe coefficient estimates for income and balance in the multiple\nlogistic regression model.\n\n```{r}\nboot.fn = function(data, index)\n  return(coef(glm(default~income+balance, data=data, family=binomial,\n                  subset=index)))\n```\n\n(c) Use the boot() function together with your boot.fn() function to\nestimate the standard errors of the logistic regression coefficients\nfor income and balance.\n\n```{r}\nlibrary(boot)\nboot(Default, boot.fn, 50)\n```\n\n(d) Comment on the estimated standard errors obtained using the\nglm() function and using your bootstrap function.\nSimilar answers\n\n9. We will now consider the Boston housing data set, from the MASS\nlibrary.\n\n(a) Based on this data set, provide an estimate for the population\nmean of medv. Call this estimate ˆμ.\n\n```{r}\nlibrary(MASS)\nsummary(Boston)\nset.seed(1)\nattach(Boston)\nmedv_mean = mean(medv)\nmedv_mean\n```\n\n(b) Provide an estimate of the standard error of ˆμ. Interpret this\nresult.\nHint: We can compute the standard error of the sample mean by\ndividing the sample standard deviation by the square root of the\nnumber of observation\n\n```{r}\nmedv_err = sd(medv) / sqrt(length(medv))\nmedv_err\n#0.40\n```\n\n(c) Now estimate the standard error of ˆμ using the bootstrap. How\ndoes this compare to your answer from (b)?\n\n```{r}\nboot.fn = function(data, index) return(mean(data[index]))\nlibrary(boot)\nbootstrap = boot(medv, boot.fn, 1000)\nbootstrap\n#0.4119374\n#Similar to answer from (b)(0.4119 vs 0.4089)\n```\n\n(d) Based on your bootstrap estimate from (c), provide a 95% confidence\ninterval for the mean of medv. Compare it to the results\nobtained using t.test(Boston$medv).\nHint: You can approximate a 95% confidence interval using the\nformula [ˆμ − 2SE(ˆμ), ˆμ + 2SE(ˆμ)].\n\n```{r}\nt.test(medv)\n#21.72953 23.33608\nc(bootstrap$t0 - 2*0.4119, bootstrap$t0 + 2*0.4119)\n#[1] 21.70901 23.35661\n#Bootstrap estimate only 0.02 differs from t.test estimate.\n```\n\n(e) Based on this data set, provide an estimate, ˆμmed, for the median\nvalue of medv in the population.\nBootstrap estimate only 0.02 away for t.test estimate.\n\ne\nmedv.med = median(medv)\nmedv.med\n```{r}\nmedian(medv)\n#21.2\n```\n\n(f) We now would like to estimate the standard error of ˆμmed. Unfortunately,\nthere is no simple formula for computing the standard\nerror of the median. Instead, estimate the standard error of the\nmedian using the bootstrap. Comment on your findings.\n\n```{r}\nboot.fn = function(data, index) return(median(data[index]))\nboot(medv, boot.fn, 1000)\n#t1* std.error 0.374358\n#Median of 21.2 with SE of 0.380. Small standard.\n```\n\n(g) Based on this data set, provide an estimate for the tenth percentile\nof medv in Boston suburbs. Call this quantity ˆμ0.1. (You\ncan use the quantile() function.)\n\n```{r}\nmedv_tenth = quantile(medv, c(0.1))\nmedv_tenth\n#  10% \n#12.75 \n```\n\n(h) Use the bootstrap to estimate the standard error of ˆμ0.1. Comment\non your findings.\n\n```{r}\nboot.fn = function(data, index) return(quantile(data[index], c(0.1)))\nboot(medv, boot.fn, 1000)\n#std.error 0.4912231\n#Tenth-percentile of 12.75 (original) with std.error of 0.49. Small standard error.\n```\n\n",
    "created" : 1518456831402.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4214218377",
    "id" : "96B40F8F",
    "lastKnownWriteTime" : 1518545950,
    "last_content_update" : 1518545950940,
    "path" : "~/Documents/UCD-pbio-rclub/ISLR_Hajar.Amini/Chapter5_Feb_13/Chapter5_Feb_13.Rmd",
    "project_path" : "Chapter5_Feb_13/Chapter5_Feb_13.Rmd",
    "properties" : {
        "last_setup_crc32" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}